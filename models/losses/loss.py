import timeimport numpy as npimport torchimport torch.nn as nnimport torch.nn.functional as Fimport chamferfrom torch.autograd import Functionfrom util.sampler import sampler, sampler_color, sampler_uv, uv2colorfrom torch.autograd import Variableclass RGBPriorLoss(nn.Module):    def __init__(self, options):        super(RGBPriorLoss, self).__init__()        self.options = options        self.chamfer_dist = ChamferDist()        self.delta_vc = None        self.meshes = self.mesh = None        self.pred_texture = None        self.device = None        self.pred_vc = []        self.pre_uvs = []        self.vc_gt = None        self.pred_coord = []        self.w_chamfer = options.weight_chamfer        self.w_chamfer_op = options.weight_chamfer_opposite        self.l2_loss = nn.MSELoss(reduction='mean')        self.part_n = None    def forward(self, output, targets, faces_gt, colors, hr_texture, lr_texture, gt_texture, uvs_gt, face_uvs_gt):        self.pred_texture = hr_texture[0]        consistent_loss = edge_loss = texture_chamfer_loss = lap_loss = beam_loss = area_loss = 0        # for i,mesh in enumerate(self.meshes):        self.mesh = np.asarray([self.meshes[self.part_n]])        self.delta_vc = self.delta_e2c(output)        pred_coord = torch.tensor(self.mesh[0].vs, dtype=torch.float,                                  device=self.device) if colors is not None else None        uvs_gt = torch.tensor(uvs_gt[self.part_n], dtype=torch.float,                              device=self.device) if uvs_gt is not None else None        face_uvs_gt = torch.tensor(face_uvs_gt[self.part_n], dtype=torch.long,                                   device=self.device).unsqueeze(0) if uvs_gt is not None else None        vc_gt = torch.tensor(colors[self.part_n], dtype=torch.float,                             device=self.device)        if self.options.texture:            self.vc_gt = vc_gt = uv2color(vc_gt[:, :2], gt_texture)        # save_obj(targets[self.part_n], faces_gt[self.part_n], '', 'tmp.obj', colors=vc_gt.detach().cpu().numpy())        f_gt = torch.tensor(faces_gt[self.part_n], dtype=torch.long,                            device=self.device).unsqueeze(0)        gt_coord = torch.tensor(targets[self.part_n], device=self.device).float()        pred_vc = self.delta_vc + 0.5        pred_coord = pred_coord.unsqueeze(0)        if len(self.pred_coord) < self.options.batch_size:            self.pred_coord.append(pred_coord)  #            self.pred_vc.append(pred_vc.unsqueeze(0))  #        else:            self.pred_coord[self.part_n] = pred_coord            self.pred_vc[self.part_n] = pred_vc.unsqueeze(0)        faces = torch.tensor(self.mesh[0].faces, dtype=torch.long, device=self.device).unsqueeze(0)        face_uvs = torch.tensor(self.mesh[0].face_uvs, dtype=torch.long, device=self.device).unsqueeze(0)        uvs = torch.tensor(self.mesh[0].uvs, dtype=torch.float, device=self.device)        # if len(self.pred_uvs) < self.options.batch_size and uvs_gt is not None:        # 	self.pre_uvs.append(sample_uv[0][idx2[0].long()])        sample_num = pred_vc.shape[0] * 10        # print(sample_num)        if self.options.sample_gt:            sampler_coord, sample_norm, sample_vc = sampler_color(f_gt, gt_coord.unsqueeze(0), sample_num,                                                                  colors=vc_gt.unsqueeze(0),                                                                  bypass=self.options.no_sample)            dist1, dist2, idx1, idx2 = self.chamfer_dist(sampler_coord, self.pred_coord[self.part_n])            gt_color = sample_vc[0][idx2[0].long()]            pre_color = pred_vc[idx1[0].long()]            chamfer_loss = self.w_chamfer * torch.mean(torch.abs(pred_vc - gt_color)) + \                           self.w_chamfer_op * torch.mean(torch.abs(pre_color - sample_vc))            loss = chamfer_loss        elif self.options.texture:            k = self.options.sample_gauss            sigma = self.options.sample_sigma - self.options.sample_sigma * (self.options.cur_step % 500) / \                    (500 * 2)            sample_num = int(pred_vc.shape[0])            consistent_loss = self.cal_consistent_loss(faces[0], self.pred_vc[self.part_n][0], face_uvs[0], uvs,                                                       self.pred_texture)            sample_coord, _, sample_uvs = sampler_uv(faces, self.pred_coord[self.part_n], sample_num,                                                     uvs=uvs.unsqueeze(0), face_uvs=face_uvs)            sample_vc = uv2color(sample_uvs[0], self.pred_texture).unsqueeze(0)            gt_coord = gt_coord.unsqueeze(0)            pair_dist = self.pairwise_dist(gt_coord, sample_coord)  # (B,M,N)            sample_knn_dist, sample_knn_idx = pair_dist.topk(k, largest=False, dim=-1)            gt_knn_dist, gt_knn_idx = pair_dist.topk(k, largest=False, dim=-2)            gt_knn_idx = gt_knn_idx.permute(0, 2, 1).contiguous()            gt_knn_dist = gt_knn_dist.permute(0, 2, 1).contiguous()            gt_color = vc_gt[sample_knn_idx[0].view(-1)].view(-1, k, 3)            gt_ratio = torch.exp(-(sample_knn_dist[0] / (2 * (sigma ** 2))))            mask = gt_ratio == 0            mask[:, 1:] = 0            gt_ratio[mask] = 1            gt_ratio = gt_ratio / torch.sum(gt_ratio, dim=-1, keepdim=True)            gt_gauss_color = torch.sum(gt_color * gt_ratio.unsqueeze(-1), dim=1)            pre_color = sample_vc[0][gt_knn_idx[0].view(-1)].view(-1, k, 3)            pre_ratio = torch.exp(-(gt_knn_dist[0] / (2 * (sigma ** 2))))            mask = pre_ratio == 0            mask[:, 1:] = 0            pre_ratio[mask] = 1            pre_ratio = pre_ratio / torch.sum(pre_ratio, dim=-1, keepdim=True)            pre_gauss_color = torch.sum(pre_color * pre_ratio.unsqueeze(-1), dim=1)            texture_chamfer_loss = self.w_chamfer * torch.mean(torch.abs(sample_vc[0] - gt_gauss_color)) + \                                   self.w_chamfer_op * torch.mean(torch.abs(pre_gauss_color - vc_gt))            sample_coord, sample_norm, sample_vc = sampler_color(faces, self.pred_coord[self.part_n], sample_num,                                                                 colors=self.pred_vc[self.part_n],                                                                 bypass=self.options.no_sample)            pair_dist = self.pairwise_dist(gt_coord, sample_coord)  # (B,M,N)            sample_knn_dist, sample_knn_idx = pair_dist.topk(k, largest=False, dim=-1)            gt_knn_dist, gt_knn_idx = pair_dist.topk(k, largest=False, dim=-2)            gt_knn_idx = gt_knn_idx.permute(0, 2, 1).contiguous()            gt_knn_dist = gt_knn_dist.permute(0, 2, 1).contiguous()            gt_color = vc_gt[sample_knn_idx[0].view(-1)].view(-1, k, 3)            gt_ratio = torch.exp(-(sample_knn_dist[0] / (2 * (sigma ** 2))))            mask = gt_ratio == 0            mask[:, 1:] = 0            gt_ratio[mask] = 1            gt_ratio = gt_ratio / torch.sum(gt_ratio, dim=-1, keepdim=True)            gt_gauss_color = torch.sum(gt_color * gt_ratio.unsqueeze(-1), dim=1)            pre_color = sample_vc[0][gt_knn_idx[0].view(-1)].view(-1, k, 3)            pre_ratio = torch.exp(-(gt_knn_dist[0] / (2 * (sigma ** 2))))            mask = pre_ratio == 0            mask[:, 1:] = 0            pre_ratio[mask] = 1            pre_ratio = pre_ratio / torch.sum(pre_ratio, dim=-1, keepdim=True)            pre_gauss_color = torch.sum(pre_color * pre_ratio.unsqueeze(-1), dim=1)            chamfer_loss = vertex_chamfer_loss = self.w_chamfer * torch.mean(torch.abs(sample_vc[0] - gt_gauss_color)) + \                                                 self.w_chamfer_op * torch.mean(torch.abs(pre_gauss_color - vc_gt))            loss = consistent_loss + vertex_chamfer_loss + texture_chamfer_loss        elif self.options.sample_gauss > 1:            k = self.options.sample_gauss            sigma = self.options.sample_sigma - self.options.sample_sigma * (self.options.cur_step % 500) / \                    (500 * 2)            sample_num = int(pred_vc.shape[0])            sample_coord, sample_norm, sample_vc = sampler_color(faces, self.pred_coord[self.part_n], sample_num,                                                                 colors=self.pred_vc[self.part_n],                                                                 bypass=self.options.no_sample)            gt_coord = gt_coord.unsqueeze(0)            pair_dist = self.pairwise_dist(gt_coord, sample_coord)  # (B,M,N)            sample_knn_dist, sample_knn_idx = pair_dist.topk(k, largest=False, dim=-1)            gt_knn_dist, gt_knn_idx = pair_dist.topk(k, largest=False, dim=-2)            gt_knn_idx = gt_knn_idx.permute(0, 2, 1).contiguous()            gt_knn_dist = gt_knn_dist.permute(0, 2, 1).contiguous()            gt_color = vc_gt[sample_knn_idx[0].view(-1)].view(-1, k, 3)            gt_ratio = torch.exp(-(sample_knn_dist[0] / (2 * (sigma ** 2))))            mask = gt_ratio == 0            mask[:, 1:] = 0            gt_ratio[mask] = 1            gt_ratio = gt_ratio / torch.sum(gt_ratio, dim=-1, keepdim=True)            gt_gauss_color = torch.sum(gt_color * gt_ratio.unsqueeze(-1), dim=1)            pre_color = sample_vc[0][gt_knn_idx[0].view(-1)].view(-1, k, 3)            pre_ratio = torch.exp(-(gt_knn_dist[0] / (2 * (sigma ** 2))))            mask = pre_ratio == 0            mask[:, 1:] = 0            pre_ratio[mask] = 1            pre_ratio = pre_ratio / torch.sum(pre_ratio, dim=-1, keepdim=True)            pre_gauss_color = torch.sum(pre_color * pre_ratio.unsqueeze(-1), dim=1)            chamfer_loss = self.w_chamfer * torch.mean(torch.abs(sample_vc[0] - gt_gauss_color)) + \                           self.w_chamfer_op * torch.mean(torch.abs(pre_gauss_color - vc_gt))            loss = chamfer_loss        elif self.options.sample_mix:            if self.options.cur_step % 600 < 150:                sampler_coord, sample_norm, sample_vc = sampler_color(f_gt, gt_coord.unsqueeze(0), sample_num,                                                                      colors=vc_gt.unsqueeze(0),                                                                      bypass=self.options.no_sample)                dist1, dist2, idx1, idx2 = self.chamfer_dist(sampler_coord, self.pred_coord[self.part_n])                gt_color = sample_vc[0][idx2[0].long()]                pre_color = pred_vc[idx1[0].long()]                chamfer_loss = self.w_chamfer * torch.mean(torch.abs(pred_vc - gt_color)) + \                               self.w_chamfer_op * torch.mean(torch.abs(pre_color - sample_vc))                loss = chamfer_loss            else:                sample_num = int(pred_vc.shape[0])                sampler_coord, sample_norm, sample_vc = sampler_color(faces, self.pred_coord[self.part_n], sample_num,                                                                      colors=self.pred_vc[self.part_n],                                                                      bypass=self.options.no_sample)                dist1, dist2, idx1, idx2 = self.chamfer_dist(gt_coord.unsqueeze(0), sampler_coord)                pre_color = sample_vc[0][idx1[0].long()]                dist1 = torch.sqrt(dist1)                # dist1 = (dist1 + 1e-6) / torch.mean(dist1 + 1e-6)                chamfer_loss = torch.mean(torch.abs(pre_color - vc_gt))                loss = chamfer_loss        else:            sample_num = int(pred_vc.shape[0])            sampler_coord, sample_norm, sample_vc = sampler_color(faces, self.pred_coord[self.part_n], sample_num,                                                                  colors=self.pred_vc[self.part_n],                                                                  bypass=self.options.no_sample)            dist1, dist2, idx1, idx2 = self.chamfer_dist(gt_coord.unsqueeze(0), sampler_coord)            pre_color = sample_vc[0][idx1[0].long()]            dist1 = torch.sqrt(dist1)            # dist1 = (dist1+1e-6) / torch.mean(dist1+1e-6)            chamfer_loss = torch.mean(torch.abs(pre_color - vc_gt))            loss = chamfer_loss        # _, _, _, idx2 = self.chamfer_dist(gt_coord.unsqueeze(0), self.pred_coord)        self.pred_vc[self.part_n][self.pred_vc[self.part_n] > 1] = 1        self.pred_vc[self.part_n][self.pred_vc[self.part_n] < 0] = 0        return loss, {            "loss": loss,            "loss_chamfer": chamfer_loss,            "loss_texture": texture_chamfer_loss,            "loss_consistent": consistent_loss,            "loss_edge": edge_loss,            "loss_area": area_loss,            "loss_lap": lap_loss,            "loss_beam": beam_loss        }    def pairwise_dist(self, xyz1, xyz2):        r_xyz1 = torch.sum(xyz1 * xyz1, dim=2, keepdim=True)  # (B,N,1)        r_xyz2 = torch.sum(xyz2 * xyz2, dim=2, keepdim=True)  # (B,M,1)        mul = torch.matmul(xyz2, xyz1.permute(0, 2, 1))  # (B,M,N)        dist = r_xyz2 - 2 * mul + r_xyz1.permute(0, 2, 1)  # (B,M,N)        return torch.abs(dist)    def cal_consistent_loss(self, faces, colors, face_uvs, uvs, texture):        faces_flatten = faces.view(-1)  # (nf * 3)        face_colors = colors[faces_flatten]  # nf3 * 3        face_uvs_flatten = face_uvs.view(-1)  # (nf * 3)        face_uvs = uvs[face_uvs_flatten]  # nf3 * 2        texture_colors = uv2color(face_uvs, texture)        return torch.mean(torch.abs(texture_colors - face_colors))    # delta_e to delta_v    def delta_e2c(self, output):        mesh = self.mesh[0]        output = output.squeeze(0).t()        edges = mesh.edges        edges_sides = mesh.edges_sides        # print(output)        vsd = torch.zeros(size=[len(mesh.vs), 24, 3], device=self.device)  # 24 is max degree of vertex,maybe change        vsd[edges[:, 0], edges_sides[:, 0], :] += output[:edges.shape[0], :3]        vsd[edges[:, 1], edges_sides[:, 1], :] += output[:edges.shape[0], 3:]        vsd = vsd.sum(dim=1) / (vsd != 0).sum(dim=1).float()        if torch.any((vsd != 0).sum(dim=1).float() < 2e-5):            print("error! NaN in delta_e2c")        return vsdclass MeshPriorLoss(nn.Module):    def __init__(self, options):        super(MeshPriorLoss, self).__init__()        self.options = options        self.chamfer_dist = ChamferDist()        self.delta_vs = None        self.delta_vc = None        self.meshes = self.mesh = None        self.device = None        self.pred_coord = []        self.pred_color = []        self.w_edge = options.weight_edge_loss        self.w_area = options.weight_area_loss        self.w_normal = options.weight_normal_loss        self.w_move = options.weight_move_loss        self.w_chamfer = options.weight_chamfer        self.w_chamfer_op = options.weight_chamfer_opposite        self.w_lap = options.weight_lap_loss        self.w_mse = options.weight_mse_loss        self.w_beam = options.weight_beam_loss        self.w_color = options.weight_color_loss        self.l2_loss = nn.MSELoss(reduction='mean')        self.part_n = None        self.idx_init = None        self.factor_xyz = torch.tensor([75.56538,23.655998,66.17292,-42.742756,-11.807249,-0.109063]).cuda()        self.factor_dist = torch.tensor([37.95355899,7.98650955]).cuda()        self.mid_point = torch.tensor([-3.1534e+00, -2.7057e-02,  3.0419e+01]).cuda()    def forward(self, output, targets):        loss = chamfer_loss = move_loss = edge_loss = normal_loss = lap_loss = beam_loss = 0        # for i,mesh in enumerate(self.meshes):        self.mesh = np.asarray([self.meshes[self.part_n]])        self.delta_vs = self.delta_e2v(output)        # geo_color or not        if self.options.geo_color:            self.delta_vc = self.delta_vs[:,3:]            self.delta_vs = self.delta_vs[:,:3]        # abs vs or not        if self.options.abs_vs:            pred_coord = self.delta_vs        else:            pred_coord = torch.tensor(self.mesh[0].vs, dtype=torch.float,                                      device=self.device) + self.delta_vs        pred_coord = pred_coord.unsqueeze(0)        if len(self.pred_coord) < self.options.batch_size:            self.pred_coord.append(pred_coord)  #            if self.options.geo_color:                self.pred_color.append(pred_coord)        else:            self.pred_coord[self.part_n] = pred_coord        faces = torch.tensor(self.mesh[0].faces, dtype=torch.long, device=self.device).unsqueeze(0)        move_loss = self.w_move * F.smooth_l1_loss(            self.delta_vs, torch.zeros_like(self.delta_vs), reduction='mean') if self.w_move > 0 else 0        edge_loss = self.w_edge * self.cal_edge_loss() if self.w_edge > 0 else 0        area_loss = self.w_area * self.cal_area_loss(faces, self.pred_coord[self.part_n]) if self.w_area > 0 else 0        gt_coord = torch.tensor(targets[0][self.part_n], device=self.device).float()        # # chamfer_losss        # if self.options.method == 'chamfer':        #     sample_num = int((self.options.ninput_edges / 2 +        #                       self.options.cur_step * self.options.ninput_edges / self.options.epoch_steps)*2)        #     # sampler_coord, sample_norm, _ = sampler(faces, self.pred_coord[self.part_n],        #     #                                         sample_num, bypass=self.options.no_sample)        #        #     #sample uvs        #     sampler_coord, _, sample_uvs = sampler_uv(        #         torch.from_numpy(self.mesh[0].faces).unsqueeze(0).cuda(),        #         pred_coord,        #         sample_num,        #         torch.from_numpy(self.mesh[0].uvs).unsqueeze(0).cuda(),        #         torch.from_numpy(self.mesh[0].face_uvs).unsqueeze(0).cuda(),        #     )        #     vc_gt = uv2color(sample_uvs[0],torch.from_numpy(self.mesh[0].texture).cuda())        #     #gt_faces = torch.tensor(targets[1], dtype=torch.long, device=self.device).unsqueeze(0)        #     #sigma = self.options.ratio_gt_sample * ( 1 - (self.options.cur_step / self.options.epoch_steps)*0.5)        # # if self.options.gt_sample:        # #     gt_sampler, _, ratio = sampler(gt_faces, gt_coord.unsqueeze(0),        # #                                        int(sample_num * 2), bypass=self.options.no_sample,        # #                                        sigma=sigma)        # #     dist1, dist2, idx1, idx2 = self.chamfer_dist(gt_sampler, sampler_coord)        #     # ratio_gt_sample or not        #     # if self.options.ratio_gt_sample > 0.:        #     #     # gt_sampler, _ ,ratio = sampler(gt_faces, gt_coord.unsqueeze(0),        #     #     # 							   int(sample_num*1.5), bypass=self.options.no_sample)        #     #     dist1 *= ratio        #     #     dist2 *= ratio[0][idx2.long()]        #     # else:        #     # 	dist1, dist2, idx1, idx2 = self.chamfer_dist(gt_coord.unsqueeze(0), sampler_coord)        # #geo_color        # dist1, dist2, idx1, idx2 =  self.chamfer_dist(gt_coord.unsqueeze(0),torch.from_numpy(self.mesh[0].vs).unsqueeze(0).cuda().float())        # vc_init = torch.from_numpy(targets[2][self.part_n]).cuda()[idx2[0].long()]        # pred_vc = vc_init + self.delta_vc        # sample_num = int((self.options.ninput_edges / 2 +        #                   self.options.cur_step * self.options.ninput_edges / self.options.epoch_steps)*2)        # #sample uvs        # sample_coord, _, sample_uvs,sample_color = sampler_uv(        #     torch.from_numpy(self.mesh[0].faces).unsqueeze(0).cuda(),        #     pred_coord,        #     sample_num,        #     torch.from_numpy(self.mesh[0].uvs).unsqueeze(0).cuda(),        #     torch.from_numpy(self.mesh[0].face_uvs).unsqueeze(0).cuda(),        #     pred_vc.unsqueeze(0)        # )        # vc_gt = uv2color(sample_uvs[0],torch.from_numpy(self.mesh[0].texture).cuda())        # dist1, dist2, idx1, idx2 = self.chamfer_dist(gt_coord.unsqueeze(0), sample_coord)        sample_num = int((self.options.ninput_edges / 2 +                          self.options.cur_step * self.options.ninput_edges / self.options.epoch_steps)*2)        sample_coord, sample_norm, _ = sampler(faces, self.pred_coord[self.part_n],sample_num)        dist1, dist2, idx1, idx2 = self.chamfer_dist(gt_coord.unsqueeze(0), sample_coord)        if self.w_mse>0:            vc_uv = torch.from_numpy(self.mesh[0].vc[:, :2]).float()            sample_coord, _, sample_uvs = sampler_uv(                torch.from_numpy(self.mesh[0].faces).unsqueeze(0).cuda(),                pred_coord,                sample_num,                torch.from_numpy(self.mesh[0].uvs).unsqueeze(0).cuda(),                torch.from_numpy(self.mesh[0].face_uvs).unsqueeze(0).cuda(),            )            mse_coord = uv2color(sample_uvs[0],torch.from_numpy(self.mesh[0].texture_np).cuda())            sample_coord = sample_coord.squeeze(0)            if self.options.dist:                sample_coord = torch.sqrt(torch.sum((sample_coord-self.mid_point)**2, dim=-1, keepdim=True))                #mse_coord = mse_coord*self.factor_dist[0] + self.factor_dist[1]            else:                mse_coord = mse_coord*self.factor_xyz[0:3] + self.factor_xyz[3:]            dist1, dist2, idx1, idx2 = self.chamfer_dist(gt_coord.unsqueeze(0), sample_coord.unsqueeze(0))        #color_loss = self.l2_loss(vc_gt.unsqueeze(0),sample_color) * self.w_color if self.w_color > 0 else 0        color_loss = 0        mse_loss = self.l2_loss(sample_coord,mse_coord)*self.w_mse if self.w_mse > 0 else 0        chamfer_loss = self.w_chamfer * (torch.mean(torch.sqrt(dist1)) +                                          self.w_chamfer_op * torch.mean(torch.sqrt(dist2)))        normal_loss = self.w_normal * self.cal_normal_loss(pred_coord) if self.w_normal > 0 else 0        lap_loss = self.w_lap * \                   self.cal_laplace_loss(self.mesh[0].vs, self.pred_coord[self.part_n]) if self.w_lap > 0 else 0        beam_loss = 0        # beam_loss = self.w_beam * self.cal_beam_loss(sampler_coord, sample_norm, gt_coord,        #                                              k=sample_num // self.options.beam_k_ratio,        #                                              radius=self.options.beam_rad) if self.w_beam > 0 else 0        # # fix_idx loss        # elif self.options.method == 'fix_idx':        #     vs_init = self.mesh[0].vs        #     vs_init = torch.from_numpy(vs_init).float().unsqueeze(0).cuda()        #     _, _, idx, _ = self.chamfer_dist(gt_coord.unsqueeze(0), vs_init)        #     chamfer_loss = torch.mean(        #         torch.norm(pred_coord.squeeze(0)[idx.long().squeeze(0)] - gt_coord.squeeze(0), dim=1) ** 2)        #     normal_loss = lap_loss = beam_loss = 0.        #        # else:        #     raise        loss = (chamfer_loss + move_loss + edge_loss + lap_loss + beam_loss + color_loss + mse_loss)        # if beam_gap_loss > chamfer_loss:        #     self.options.weight_beam_gap /= 2.0        if move_loss > chamfer_loss * self.options.theta:            self.w_move /= 2.0        if edge_loss > chamfer_loss * self.options.theta:            self.w_edge /= 2.0        if area_loss > chamfer_loss * self.options.theta:            self.w_area /= 2.0        # if normal_loss > chamfer_loss:        #     self.w_normal /= 1.5        if lap_loss > chamfer_loss:            self.w_lap /= 2.0        return loss, {            "loss": loss,            "loss_chamfer": chamfer_loss,            "loss_mse":mse_loss,            "loss_normal": normal_loss,            "loss_move": move_loss,            "loss_edge": edge_loss,            "loss_area": area_loss,            "loss_lap": lap_loss,            "loss_beam": beam_loss,            "loss_color": color_loss        }    def cal_area_loss(self, faces, verts):        batch_size = faces.shape[0]        faces_flatten = faces.view(batch_size, -1) - 1  # b * (nv * 3)        face_verts = verts[:, faces_flatten[0]].view(batch_size, -1, 3, 3)  # b * nf * 3 * 3        for i in range(batch_size):            # could batch?            face_verts[i] = verts[i, faces_flatten[i]].view(-1, 3, 3)  # nf * 3 * 3        v1 = face_verts[:, :, 1] - face_verts[:, :, 0]  # b * nv * 3        v2 = face_verts[:, :, 2] - face_verts[:, :, 0]  # b * nv * 3        # cal face areas        areas = torch.sqrt(            torch.sum(v1 * v1, dim=-1) * torch.sum(v2 * v2, dim=-1) - (torch.sum(v1 * v2, dim=-1)) ** 2 + 1e-7) / 2.0        return torch.mean(areas)    def laplace_coord(self, input, lap_idx):        input = input.type(torch.float32)        idx = torch.tensor(lap_idx, dtype=torch.int64, device=self.device)        mask = idx < 0        valid_idx = idx.clone()        valid_idx[mask] = 0        v = input[valid_idx]        v[mask] = 0        lap_coord = input - v.sum(dim=1) / (v.sum(dim=2) != 0).type(torch.float32).sum(dim=1).unsqueeze(-1)        return lap_coord    def cal_laplace_loss(self, input, output):        input = torch.tensor(input, device=self.device)        lap_in = self.laplace_coord(input, self.mesh[0].lap_idx)        lap_out = self.laplace_coord(output.squeeze(0), self.mesh[0].lap_idx)        lap_loss = self.l2_loss(lap_in, lap_out) * lap_in.size(-1)        return lap_loss    def pairwise_dist(self, xyz1, xyz2):        r_xyz1 = torch.sum(xyz1 * xyz1, dim=2, keepdim=True)  # (B,N,1)        r_xyz2 = torch.sum(xyz2 * xyz2, dim=2, keepdim=True)  # (B,M,1)        mul = torch.matmul(xyz2, xyz1.permute(0, 2, 1))  # (B,M,N)        dist = r_xyz2 - 2 * mul + r_xyz1.permute(0, 2, 1)  # (B,M,N)        return dist    def cal_beam_loss(self, sample_coord, sample_norm, gt_coord, radius=1e-2, k=5):        # TODO: very memory consuming, need some optimizations        gt_coord = gt_coord.unsqueeze(0)        pair_dist = self.pairwise_dist(gt_coord, sample_coord)  # (B,M,N)        sample_knn_dist, sample_knn_idx = pair_dist.topk(k, largest=False, dim=-1)        gt_knn_dist, gt_knn_idx = pair_dist.topk(k, largest=False, dim=-2)        gt_knn_thresh = gt_knn_dist[:, -1, :]        sample_knn_thresh = gt_knn_thresh[0, sample_knn_idx]        knn_mask = sample_knn_dist <= sample_knn_thresh        knn_mask = torch.any(knn_mask, dim=-1)        pair_dot = torch.matmul(sample_norm, gt_coord.permute(0, 2, 1))        pair_radius = pair_dist - pair_dot ** 2        mask = pair_radius > (radius ** 2)        loss_mask = torch.all(mask, dim=-1)        pair_dist[mask] = 1e5        min_dist, _ = torch.min(pair_dist, dim=-1)        min_dist[loss_mask] = 0        min_dist[knn_mask] = 0        min_dist = torch.sqrt(torch.abs(min_dist))        beam_loss = torch.mean(min_dist)        return beam_loss    def cal_edge_loss(self):        coord = self.pred_coord[self.part_n]        edges = torch.tensor(self.mesh[0].edges, dtype=torch.long, device=self.device)        edges_flatten = edges.reshape(-1)        coord_flatten = coord[:, edges_flatten]        edge_coords = coord_flatten.reshape((-1, 2, 3))        edge_length = torch.mean(torch.sum((edge_coords[:, 0] - edge_coords[:, 1]) ** 2, dim=1))        return edge_length    def cal_normal_loss(self,vs):        vs.squeeze_(0)        mesh = self.mesh[0]        edges = mesh.edge_points        vec_edge01 = F.normalize(vs[edges[:, 0]] - vs[edges[:, 1]], dim=1)        vec_edge02 = F.normalize(vs[edges[:, 0]] - vs[edges[:, 2]], dim=1)        vec_edge03 = F.normalize(vs[edges[:, 0]] - vs[edges[:, 3]], dim=1)        face1_normal = F.normalize(torch.mul(vec_edge01,vec_edge02),dim=1)        face2_normal = F.normalize(torch.mul(vec_edge01,vec_edge03),dim=1)        cos  = 1 - torch.mean(torch.abs(torch.sum(face1_normal * face2_normal, dim=1)))        # normals = F.normalize(v_normals[edges[:, 0]], dim=1)        # cos = torch.mean(torch.abs(torch.sum(vec_edges * normals, dim=1)))        # ##return cos        #        # face_side = mesh.face_side        # edge1 = pred_coord[mesh.faces[:, 0]] - pred_coord[mesh.faces[:, 1]]        # edge2 = pred_coord[mesh.faces[:, 1]] - pred_coord[mesh.faces[:, 2]]        # face_normal = torch.mul(edge1, edge2)        # v_normals = torch.zeros(size=[len(mesh.vs), 24, 3], device=self.device)        # v_normals[:, face_side[:, :], :] += face_normal[face_side[:, :]]        # v_normals = v_normals.sum(dim=1)        #        # normals = F.normalize(v_normals[edges[:, 0]], dim=1)        # cos = torch.mean(torch.abs(torch.sum(vec_edges * normals, dim=1)))        return cos    # delta_e to delta_v    def delta_e2v(self, output):        mesh = self.mesh[0]        output = output.squeeze(0).t()        edges = mesh.edges        edges_sides = mesh.edges_sides        # print(output)        vsd = torch.zeros(size=[len(mesh.vs), 24, 3], device=self.device)  # 24 is max degree of vertex,maybe change        vsd[edges[:, 0], edges_sides[:, 0], :] += output[:edges.shape[0], :3]        vsd[edges[:, 1], edges_sides[:, 1], :] += output[:edges.shape[0], 3:]        vsd = vsd.sum(dim=1) / (vsd != 0).sum(dim=1).float()        return vsd# Chamfer's distance module @thibaultgroueix# GPU tensors onlyclass ChamferFunction(Function):    @staticmethod    def forward(ctx, xyz1, xyz2):        batchsize, n, _ = xyz1.size()        _, m, _ = xyz2.size()        dist1 = torch.zeros(batchsize, n)        dist2 = torch.zeros(batchsize, m)        idx1 = torch.zeros(batchsize, n).type(torch.IntTensor)        idx2 = torch.zeros(batchsize, m).type(torch.IntTensor)        dist1 = dist1.cuda()        dist2 = dist2.cuda()        idx1 = idx1.cuda()        idx2 = idx2.cuda()        chamfer.forward(xyz1, xyz2, dist1, dist2, idx1, idx2)        ctx.save_for_backward(xyz1, xyz2, idx1, idx2)        return dist1, dist2, idx1, idx2    @staticmethod    def backward(ctx, graddist1, graddist2, _idx1, _idx2):        xyz1, xyz2, idx1, idx2 = ctx.saved_tensors        graddist1 = graddist1.contiguous()        graddist2 = graddist2.contiguous()        gradxyz1 = torch.zeros(xyz1.size())        gradxyz2 = torch.zeros(xyz2.size())        gradxyz1 = gradxyz1.cuda()        gradxyz2 = gradxyz2.cuda()        chamfer.backward(xyz1, xyz2, gradxyz1, gradxyz2, graddist1, graddist2, idx1, idx2)        return gradxyz1, gradxyz2class ChamferDist(nn.Module):    def __init__(self):        super(ChamferDist, self).__init__()    def forward(self, input1, input2):        return ChamferFunction.apply(input1, input2)if __name__ == "__main__":    batch_size = 8    n, m = 30, 20    xyz1 = torch.rand((batch_size, n, 3)).cuda()    xyz2 = torch.rand((batch_size, m, 3)).cuda()    #    # dist1 = torch.zeros(batch_size, n).cuda()    # dist2 = torch.zeros(batch_size, m).cuda()    #    # idx1 = torch.zeros((batch_size, n), dtype=torch.int).cuda()    # idx2 = torch.zeros((batch_size, m), dtype=torch.int).cuda()    #    # chamfer.forward(xyz1, xyz2, dist1, dist2, idx1, idx2)    # print(dist1)    # print(dist2)    # print(idx1)    # print(idx2)    a = ChamferDist()    print("test")    print(a(xyz1, xyz2))